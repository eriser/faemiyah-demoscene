#summary dnload - minimal binary generator for *nix operating systems
#labels Featured

= dnload.py =

`dnload.py` is a script for generating minimal ELF binaries from C code. It serves no practical real-world use case, but can be utilized to create those nifty size-limited demoscene productions some people seem to be interested in.

<wiki:toc max_depth="3" />

== System requirements ==

The bridging header file should be generatable on FreeBSD, Linux, Windows, and possibly various unmentioned `*`nix platforms with a up-to-date Python installation.

Generating a final binary is supported on FreeBSD and Linux. Due to practical purposes (i.e. the OS of choice of the author), the primary target operating system is FreeBSD. Existence of binutils toolchain (`as`, `ld`, etc.) on the system is assumed.

The script is self-contained, and should require no external python packages to be installed. Both Python versions 2.7.x and 3.x should be fine.

If compiling without size optimizations, you will need GLEW and SDL development files installed. This is subject to change if/when other backends are added.

*NOTE:* Cross-compilation is not (yet?) supported. Building of binaries must be done on the actual target system. As earlier mentioned, this currently only includes `FreeBSD-ia32` and `Linux-ia32`. If you want to develop 32-bit software on a 64-bit system, you'll probably want to set up a chroot/jail environment.

----

= Usage =

Mainly, the script will be used for two purposes:
  * Building size-limited binaries directly from C/C++ source on systems where compilation is supported.
  * Generating a header file to hide the complexities of size-limited linking. This can be done both on systems where compilation is supported and where it is not, since some developers might be working on other platforms.

== Getting started ==

To understand how to use the script, a simple example will clarify the operation with more ease than any lengthy explanation would. We will be doing the traditional hello world program.

First, clone the repository:

{{{
svn checkout http://faemiyah-demoscene.googlecode.com/svn/trunk/dnload
}}}

The checked out repository will have the `dnload.py` script in the root folder. Our minimal example is included in the `src/` folder and called `hello_world.cpp`. The example looks like this (removing non-essential comments):

{{{
#include "dnload.h"

#if !defined(USE_LD)
#if defined(__clang__)
void *environ;
void *__progname;
extern "C" void _start();
#else
void *environ __attribute__((externally_visible));
void *__progname __attribute__((externally_visible));
extern "C" void _start() __attribute__((externally_visible));
#endif
#endif

#if defined(USE_LD)
int main()
#else
void _start()
#endif
{
  dnload();
  dnload_puts("Hello World!");

#if defined(USE_LD)
  return 0;
#elif defined(asm_exit)
  asm_exit();
#endif
}
}}}

The first thing we need to do, is to ensure that our header is up to date. To do this, run:

{{{
python dnload.py src/hello_world.cpp -v
}}}

This should produce output somewhat akin to this:

{{{
Header file 'dnload.h' found in path 'src/'.
Trying binary 'g++49'... found
Trying binary 'sdl-config'... found
Executing command: sdl-config --cflags
Analyzing source file 'src/hello_world.cpp'.
Executing command: g++49 src/hello_world.cpp -D_GNU_SOURCE=1 -D_REENTRANT -D_THREAD_SAFE -DDNLOAD_H -I/usr/local/include -I/usr/local/include/SDL -E
Symbols found: ['puts']
Wrote header file 'src/dnload.h'.
}}}

You should now have an up-to date header file that can be used to build the program. You may take a look at the contents of the header, but it will be explained in detail [#The_quest_for_minimal_ELF32_binaries later on].

== Building without size optimizations ==

Most of the time when developing, the programmer is hardly interested in building size-optimized programs all the time. For this purpose, everything in the generated header file is wrapped to compile-time guards that allow us to compile the program as normal, from Makefiles, Autotools scripts, CMake or even Visual Studio projects.

To do this, just run (replacing with your favorite compiler and favorite flags):

{{{
> clang++ -o src/hello_world src/hello_world.cpp -DUSE_LD -I/usr/local/include `sdl-config --cflags` -O2 -s && ./src/hello_world
Hello World!
}}}

*NOTE:* The include directory and invoking sdl-config are currently necessary since SDL backend is what will be included by the generated headers.

The relevant part here is the `USE``_``LD` definition. When it is turned on all 'tricks' will essentially evaluate to NOP, and all calls made with the reserved `dnload``_` prefix will just call the functions as normal.

The name `USE``_``LD` does not make sense per se, but is preserved as such due to historical reasons in earlier Faemiyah prods. You may change the definition with the `-d` or `--definition` command line argument when invoking the script.

== Compiling a size-optimized binary ==

After generating the binary normally, we can invoke the script to perform full compilation:

{{{
python dnload.py -v src/hello_world.cpp -o hello_world -lc
}}}

You might notice the flags are similar to the conventions used in other binary utilities. This is intentional. The command should produce output somewhat similar to this:

{{{
Header file 'dnload.h' found in path 'src/'.
Trying binary 'g++49'... found
Trying binary 'sdl-config'... found
Executing command: sdl-config --cflags
Trying binary '/usr/local/bin/as'... found
Trying binary '/usr/local/bin/ld'... found
Trying binary '/usr/local/bin/strip'... found
Analyzing source file 'src/hello_world.cpp'.
Executing command: g++49 src/hello_world.cpp -D_GNU_SOURCE=1 -D_REENTRANT -D_THREAD_SAFE -DDNLOAD_H -I/usr/local/include -I/usr/local/include/SDL -E
Symbols found: ['puts']
Wrote header file 'src/dnload.h'.
Executing command: g++49 -S src/hello_world.cpp -o src/hello_world.S -Os -ffast-math -fno-asynchronous-unwind-tables -fno-exceptions -fno-rtti -fno-threadsafe-statics -fomit-frame-pointer -fsingle-precision-constant -fwhole-program -march=pentium4 -mpreferred-stack-boundary=2 -D_GNU_SOURCE=1 -D_REENTRANT -D_THREAD_SAFE -I/usr/local/include -I/usr/local/include/SDL
Using shared library 'libc.so.7' instead of 'libc.so'.
Merging headers phdr_interp and hash at point 1.
Merging headers hash and dynamic at point 1.
Merging headers dynamic and symtab at point 2.
Merging headers interp and strtab at point 1.
Read 7 sections in 'src/hello_world.S': text, text, text, rodata, text, text, note
Erasing function header from '_start': 4 lines.
Erasing function footer after interrupt '128': 9 lines.
Wrote assembler source 'src/hello_world.final.S'.
Executing command: /usr/local/bin/as src/hello_world.final.S -o src/hello_world.o
Executing command: /usr/local/bin/ld --oformat=binary --entry=0x8048000 src/hello_world.o -o src/hello_world.stripped
Executing command: xz --format=lzma --lzma1=preset=9e,lc=1,lp=0,pb=0 --stdout src/hello_world.stripped
Wrote 'src/hello_world': 414 bytes
}}}

When ran, it will do just the same:

{{{
> ./src/hello_world
Hello World!
}}}

== Examining the source ==

First of all, all programs wanting to use the loader will have to include the generated header file.

{{{
#include "dnload.h"
}}}

This will internally include the relevant loader and some other header present in the `src/` subdirectory in the repo. The user may of course include any other source files necessary, but all function calls should be done through the interface wrapped herein.

More interesting is the declaration of the main function:

{{{
#if !defined(USE_LD)
#if defined(__clang__)
void *environ;
void *__progname;
extern "C" void _start();
#else
void *environ __attribute__((externally_visible));
void *__progname __attribute__((externally_visible));
extern "C" void _start() __attribute__((externally_visible));
#endif
#endif

/** \brief Object file starting point. */
#if defined(USE_LD)
int main()
#else
void _start()
#endif
{
}}}

If the macro `USE``_``LD` would be defined, all this would simply evaluate to `int main() {`, which is the entry point the compiler would except to find.

However, main() is not the entry point actually used by the system. In actuality, the linker will generate code that will perform initialization of global variables, environment, etc., and only afterwards pass the control to the main function provided by the user. Since we're aiming for a small binary, any initialization that needs doing, we'll be doing ourselves. The actual program execution will begin at a symbol traditionally called *`_`start*, which is exactly what we will be using.

*NOTE:* When manually creating the program headers, the symbol would not necessarily need to be named ``_`start` - it could be anything, the name will be stripped out anyway. However, why break a known convention?

Besides the entry point, we see two other symbols named *environ* and *__progname*, that might seem nonsensical, as they are not used anywhere in the program (they will also not be used inside the generated headers). Taking a look into the standard C library (`/lib/libc.so.7` on FreeBSD) will clarify.

{{{
> readelf -a /lib/libc.so.7
...
Symbol table '.dynsym' contains 3079 entries:
   Num:    Value  Size Type    Bind   Vis      Ndx Name
     0: 00000000     0 NOTYPE  LOCAL  DEFAULT  UND 
     1: 00000000     0 NOTYPE  WEAK   DEFAULT  UND _Jv_RegisterClasses
     2: 00000000     0 NOTYPE  GLOBAL DEFAULT  UND __progname
     3: 00000000     0 NOTYPE  GLOBAL DEFAULT  UND environ
...
}}}

These are not symbols we need, instead, they are symbols that are expected from us. In practice, the dynamic linking procedure will fail if the program symbol table does not contain them. Thus, we need to declare them, even if they do nothing.

The `__attribute__((externally_visible))` that might also seem weird is just there due to Gnu C Compiler semantics. To make g++ discard all irrelevant code, we pass `-fwhole-program` to its command line. Unfortunately, unless the compiler finds something it thinks it could use, this will actually cause the discard of _everything_ within the source file. We simply explicitly mark the places the dependency graph build should start from. Clang does not seem to require or support this attribute.

The two first lines of main conpose the actual program:

{{{
dnload();
dnload_puts("Hello World!");
}}}

This will perform of dynamic loading of all required symbols (here: only `puts`) and call the located function pointer. After saying our hellos, the only thing left to do is to exit the program:

{{{
#if defined(USE_LD)
  return 0;
#elif defined(asm_exit)
  asm_exit();
#endif
}}}

Since we already discarded the premise of using the default `main` procedure, no-one is going to terminate our program.

We could make it "return" but that would normally only pass control to the shell provided by the system, we now have nowhere to return to. Thus, we must make a system call[#References [11]] to terminate the program ourselves. The file [https://code.google.com/p/faemiyah-demoscene/source/browse/trunk/dnload/src/asm_exit.h `src/asm_exit.h`] (automatically included in `dnload.h`) provides a macro called `asm``_``exit()` that will do exactly this. Essentially on i386 architecture, it will evaluate into the following :

{{{
movl $1, %eax
int $128
}}}

Note that this puts nothing into `%bl` (as would be expected on Linux) or pushes nothing onto stack (as would be expected on FreeBSD). This is because we simply do not care what is the return value of the program.

Besides, the decompressor shell script that actually executes the binary would ignore it anyway.

== Other examples ==

The `src/` folder contains two other examples: `quad.cpp` and `intro.cpp`. The quad example will simply open a coder-colored window and output 8-bit music (from very short programs) for a couple of seconds.

The intro example is more interesting, since it contains a (extremely primitive) raycaster and can be compiled with CMake for a interactive program with a 'debug mode'. Just run:

{{{
cmake . && make clean all && ./src/stub -d -w
}}}

*NOTE:* you will need Boost, GLEW, etc. Chances are you already have them though.

This should open a window allowing mouse pan and WASD movement. You can still compile it with:

{{{
python dnload.py -v src/intro.cpp -o stub -lGL -lSDL
}}}

Hve fun!

== Short summary of operation ==

When invoked, the script will:
  * Probe for suitable compiler, usually `gcc` or `clang`, `cl.exe` on Windows.
  * Search for header file it was supposed to generate. By default this is called `dnload.h`.
  * Examine the location the header file was found in. If a source file was given on command line, only operate on it. Otherwise take all source files from this location.
  * Preprocess the source files with the compiler found earlier.
  * Examine preprocessor output and locate all function calls made with a specific prefix. By default this prefix is `dnload_`.
  * Generate a loader code block that locates pointers to given functions.
  * Write the header file.

If the script was invoked to additionally generate the binary:
  * Search for usual binary utilities in addition to the compiler.
  * Compile given source file with flags aiming for small code footprint.
  * Perform a series on operations on the compiler output known to further reduce code footprint.
  * Link an output binary.
  * Compress the produced binary and concatenate it with a shell scrip that will decompress and execute it.

----

= The quest for minimal ELF32 binaries =

This section of the documentation explores both the current and historical methods of reducing executable file size on `*`nix systems. If you are only interested in the current "best practice" operation of the script, you can [#Crafting_headers_manually skip directly therein].

== The shell unpack header ==

TODO: fill

== My symbol table is too big - dlopen/dlsym ==

TODO: fill

== Import by hash - scouring ELF32 headers ==

TODO: fill

== Crafting headers manually ==

TODO: fill

----

= Acknowledgements =

This script would not have been possible without the prior work done by various other parties. Especially the following parties deserve kudos for their efforts:
  * *Marq/Fit* [#References [1]] for the original unpack header and dlopen/dlsym implementation.
  * *Brian Raiter* for _A Whirlwind Tutorial on Creating Really Teensy ELF Executables for Linux_ [#References [2]] and the insight of interleaving headers.
  * *parcelshit* [#References [3]] and *las/Mercury* [#References [4]] for the original ELF32 import-by hash algorithm.
  * *Hymy* [#References [5]] and *Ye Olde Laptops Posse* [#References [6]] for earlier forays into manual ELF32 header construction.
  * *viznut/PWP* [#References [7]] for the series _Experimental music from very short C programs_ [#References [8]], a snipped of which is used in one of the examples.

The list might be missing some parties, that are thus not getting the credit they deserve. If you notice this, please help correct the error(s).

----

= Legalese =

All contained code is licenced under the [https://code.google.com/p/faemiyah-demoscene/source/browse/trunk/dnload/COPYING new BSD licence] [#References [9]].

Note that this licence only pertains to the code of the script(s) themselves. There are no restrictions imposed on the end products of the script(s) just like there are no restrictions imposed on a binary built with a compiler.

And to be honest, even that doesn't really mean anything. Just do whatever you want, but if you improve on the mechanisms, I'd probably prefer to incorporate the improvements.

----

= FAQ =

==== No-one runs 32-bit FreeBSD anymore, especially if it's only for curiosities like this. Why bother? ====

Even on a 64-bit system, you should be able to execute the result file if the compatibility layer is set up correctly. The easiest way to do it is to just install a 32-bit jail [#References [10]] and point `LD_32_LIBRARY_PATH` environment variable to the `/usr/local/lib` of that jail. This has the added benefit of enabling full 32-bit compatibility and easy cross-compiling.

There are probably easy ways to do the same on Linux, but they are out of the scope of this document.

----

= TODO =
  * Should probably create the header file in a smart(er) manner if it's not found.
  * Add cross-compilation support, at the very least between `*`nix systems and the "maximum" operation mode.
  * Only SDL/OpenGL supported right now. Should probably also support GLFW.

----

= References =

`[`1`]` [http://www.pouet.net/user.php?who=4078 Marq/Fit in Pouet]<br>
`[`2`]` [http://www.muppetlabs.com/~breadbox/software/tiny/teensy.html A Whirlwind Tutorial on Creating Really Teensy ELF Executables for Linux]<br>
`[`3`]` [http://www.pouet.net/user.php?who=9348 parcelshit in Pouet]<br>
`[`4`]` [http://www.pouet.net/user.php?who=4548 las/Mercury in Pouet]<br>
`[`5`]` [http://www.pouet.net/groups.php?which=11106 Hymy in Pouet]<br>
`[`6`]` [http://www.pouet.net/groups.php?which=11436 Ye Olde Laptops Posse in Pouet]<br>
`[`7`]` [http://www.pouet.net/user.php?who=2547 viznut/PWP in Pouet]<br>
`[`8`]` [https://www.youtube.com/watch?v=tCRPUv8V22o Music from very short programs - the 3rd iteration in Youtube]<br>
`[`9`]` [http://opensource.org/licenses/BSD-3-Clause New BSD licence]<br>
`[`10`]` [http://www.freebsd.org/doc/handbook/jails.html Chapter 15. Jails in FreeBSD manual]<br>
`[`11`]` [http://www.freebsd.org/doc/en/books/developers-handbook/x86-system-calls.html Chapter 11.3. System Calls in FreeBSD manual]