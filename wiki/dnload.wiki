#summary dnload - minimal binary generator for *nix operating systems
#labels Featured

= dnload.py =

`dnload.py` is a script for generating minimal ELF binaries from C code. It serves no practical real-world use case, but can be utilized to create those nifty size-limited demoscene productions some people seem to be interested in.

<wiki:toc max_depth="3" />

== System requirements ==

The bridging header file should be generatable on FreeBSD, Linux, Windows, and possibly various unmentioned `*`nix platforms with a up-to-date Python installation.

Generating a final binary is supported on FreeBSD and Linux. Due to practical purposes (i.e. the OS of choice of the author), the primary target operating system is FreeBSD. Existence of binutils toolchain (`as`, `ld`, etc.) on the system is assumed.

The script is self-contained, and should require no external python packages to be installed. Both Python versions 2.7.x and 3.x should be fine.

If compiling without size optimizations, you will need GLEW and SDL development files installed. This is subject to change if/when other backends are added.

*NOTE:* Cross-compilation is not (yet?) supported. Building of binaries must be done on the actual target system. As earlier mentioned, this currently only includes `FreeBSD-ia32` and `Linux-ia32`. If you want to develop 32-bit software on a 64-bit system, you'll probably want to set up a chroot/jail environment.

----

= Usage =

Mainly, the script will be used for two purposes:
  * Building size-limited binaries directly from C/C++ source on systems where compilation is supported.
  * Generating a header file to hide the complexities of size-limited linking. This can be done both on systems where compilation is supported and where it is not, since some developers might be working on other platforms.

== Getting started ==

To understand how to use the script, a simple example will clarify the operation with more ease than any lengthy explanation would. We will be doing the traditional hello world program.

First, clone the repository:

{{{
svn checkout http://faemiyah-demoscene.googlecode.com/svn/trunk/dnload
}}}

The checked out repository will have the `dnload.py` script in the root folder. Our minimal example is included in the `src/` folder and called `hello_world.cpp`. The example looks like this (removing non-essential comments):

{{{
#include "dnload.h"

#if !defined(USE_LD)
#if defined(__clang__)
void *environ;
void *__progname;
extern "C" void _start();
#else
void *environ __attribute__((externally_visible));
void *__progname __attribute__((externally_visible));
extern "C" void _start() __attribute__((externally_visible));
#endif
#endif

#if defined(USE_LD)
int main()
#else
void _start()
#endif
{
  dnload();
  dnload_puts("Hello World!");

#if defined(USE_LD)
  return 0;
#elif defined(asm_exit)
  asm_exit();
#endif
}
}}}

The first thing we need to do, is to ensure that our header is up to date. To do this, run:

{{{
python dnload.py src/hello_world.cpp -v
}}}

This should produce output somewhat akin to this:

{{{
Header file 'dnload.h' found in path 'src/'.
Trying binary 'g++49'... found
Trying binary 'sdl-config'... found
Executing command: sdl-config --cflags
Analyzing source file 'src/hello_world.cpp'.
Executing command: g++49 src/hello_world.cpp -D_GNU_SOURCE=1 -D_REENTRANT -D_THREAD_SAFE -DDNLOAD_H -I/usr/local/include -I/usr/local/include/SDL -E
Symbols found: ['puts']
Wrote header file 'src/dnload.h'.
}}}

You should now have an up-to date header file that can be used to build the program. You may take a look at the contents of the header, but it will be explained in detail [#The_quest_for_minimal_ELF32_binaries later on].

== Building without size optimizations ==

Most of the time when developing, the programmer is hardly interested in building size-optimized programs all the time. For this purpose, everything in the generated header file is wrapped to compile-time guards that allow us to compile the program as normal, from Makefiles, Autotools scripts, CMake or even Visual Studio projects.

To do this, just run (replacing with your favorite compiler and favorite flags):

{{{
> clang++ -o src/hello_world src/hello_world.cpp -DUSE_LD -I/usr/local/include `sdl-config --cflags` -O2 -s && ./src/hello_world
Hello World!
}}}

*NOTE:* The include directory and invoking sdl-config are currently necessary since SDL backend is what will be included by the generated headers.

The relevant part here is the `USE``_``LD` definition. When it is turned on all 'tricks' will essentially evaluate to NOP, and all calls made with the reserved `dnload``_` prefix will just call the functions as normal.

The name `USE``_``LD` does not make sense per se, but is preserved as such due to historical reasons in earlier Faemiyah prods. You may change the definition with the `-d` or `--definition` command line argument when invoking the script.

== Compiling a size-optimized binary ==

After generating the binary normally, we can invoke the script to perform full compilation:

{{{
python dnload.py -v src/hello_world.cpp -o hello_world -lc
}}}

You might notice the flags are similar to the conventions used in other binary utilities. This is intentional. The command should produce output somewhat similar to this:

{{{
Header file 'dnload.h' found in path 'src/'.
Trying binary 'g++49'... found
Trying binary 'sdl-config'... found
Executing command: sdl-config --cflags
Trying binary '/usr/local/bin/as'... found
Trying binary '/usr/local/bin/ld'... found
Trying binary '/usr/local/bin/strip'... found
Analyzing source file 'src/hello_world.cpp'.
Executing command: g++49 src/hello_world.cpp -D_GNU_SOURCE=1 -D_REENTRANT -D_THREAD_SAFE -DDNLOAD_H -I/usr/local/include -I/usr/local/include/SDL -E
Symbols found: ['puts']
Wrote header file 'src/dnload.h'.
Executing command: g++49 -S src/hello_world.cpp -o src/hello_world.S -Os -ffast-math -fno-asynchronous-unwind-tables -fno-exceptions -fno-rtti -fno-threadsafe-statics -fomit-frame-pointer -fsingle-precision-constant -fwhole-program -march=pentium4 -mpreferred-stack-boundary=2 -D_GNU_SOURCE=1 -D_REENTRANT -D_THREAD_SAFE -I/usr/local/include -I/usr/local/include/SDL
Using shared library 'libc.so.7' instead of 'libc.so'.
Merging headers phdr_interp and hash at point 1.
Merging headers hash and dynamic at point 1.
Merging headers dynamic and symtab at point 2.
Merging headers interp and strtab at point 1.
Read 7 sections in 'src/hello_world.S': text, text, text, rodata, text, text, note
Erasing function header from '_start': 4 lines.
Erasing function footer after interrupt '128': 9 lines.
Wrote assembler source 'src/hello_world.final.S'.
Executing command: /usr/local/bin/as src/hello_world.final.S -o src/hello_world.o
Executing command: /usr/local/bin/ld --oformat=binary --entry=0x8048000 src/hello_world.o -o src/hello_world.stripped
Executing command: xz --format=lzma --lzma1=preset=9e,lc=1,lp=0,pb=0 --stdout src/hello_world.stripped
Wrote 'src/hello_world': 414 bytes
}}}

When ran, it will do just the same:

{{{
> ./src/hello_world
Hello World!
}}}

== Examining the source ==

First of all, all programs wanting to use the loader will have to include the generated header file.

{{{
#include "dnload.h"
}}}

This will internally include the relevant loader and some other header present in the `src/` subdirectory in the repo. The user may of course include any other source files necessary, but all function calls should be done through the interface wrapped herein.

More interesting is the declaration of the main function:

{{{
#if !defined(USE_LD)
#if defined(__clang__)
void *environ;
void *__progname;
extern "C" void _start();
#else
void *environ __attribute__((externally_visible));
void *__progname __attribute__((externally_visible));
extern "C" void _start() __attribute__((externally_visible));
#endif
#endif

/** \brief Object file starting point. */
#if defined(USE_LD)
int main()
#else
void _start()
#endif
{
}}}

If the macro `USE``_``LD` would be defined, all this would simply evaluate to `int main() {`, which is the entry point the compiler would except to find.

However, main() is not the entry point actually used by the system. In actuality, the linker will generate code that will perform initialization of global variables, environment, etc., and only afterwards pass the control to the main function provided by the user. Since we're aiming for a small binary, any initialization that needs doing, we'll be doing ourselves. The actual program execution will begin at a symbol traditionally called *`_`start*, which is exactly what we will be using.

*NOTE:* When manually creating the program headers, the symbol would not necessarily need to be named `_``start` - it could be anything, the name will be stripped out anyway. However, why break a known convention?

Besides the entry point, we see two other symbols named *environ* and *__progname*, that might seem nonsensical, as they are not used anywhere in the program (they will also not be used inside the generated headers). Taking a look into the standard C library (`/lib/libc.so.7` on FreeBSD) will clarify.

{{{
> readelf -a /lib/libc.so.7
...
Symbol table '.dynsym' contains 3079 entries:
   Num:    Value  Size Type    Bind   Vis      Ndx Name
     0: 00000000     0 NOTYPE  LOCAL  DEFAULT  UND 
     1: 00000000     0 NOTYPE  WEAK   DEFAULT  UND _Jv_RegisterClasses
     2: 00000000     0 NOTYPE  GLOBAL DEFAULT  UND __progname
     3: 00000000     0 NOTYPE  GLOBAL DEFAULT  UND environ
...
}}}

These are not symbols we need, instead, they are symbols that are expected from us. In practice, the dynamic linking procedure will fail if the program symbol table does not contain them. Thus, we need to declare them, even if they do nothing.

The `__attribute__((externally_visible))` that might also seem weird is just there due to Gnu C Compiler semantics. To make g++ discard all irrelevant code, we pass `-fwhole-program` to its command line. Unfortunately, unless the compiler finds something it thinks it could use, this will actually cause the discard of _everything_ within the source file. We simply explicitly mark the places the dependency graph build should start from. Clang does not seem to require or support this attribute.

The two first lines of main compose the actual program:

{{{
dnload();
dnload_puts("Hello World!");
}}}

This will perform of dynamic loading of all required symbols (here: only `puts`) and call the located function pointer. After saying our hellos, the only thing left to do is to exit the program:

{{{
#if defined(USE_LD)
  return 0;
#elif defined(asm_exit)
  asm_exit();
#endif
}}}

Since we already discarded the premise of using the default `main` procedure, no-one is going to terminate our program.

We could make it "return" but that would normally only pass control to the shell provided by the system, we now have nowhere to return to. Thus, we must make a system call[#References [11]] to terminate the program ourselves. The file [https://code.google.com/p/faemiyah-demoscene/source/browse/trunk/dnload/src/asm_exit.h `src/asm_exit.h`] (automatically included in `dnload.h`) provides a macro called `asm``_``exit()` that will do exactly this. Essentially on i386 architecture, it will evaluate into the following :

{{{
movl $1, %eax
int $128
}}}

Note that this puts nothing into `%bl` (as would be expected on Linux) or pushes nothing onto stack (as would be expected on FreeBSD). This is because we simply do not care what is the return value of the program.

Besides, the decompressor shell script that actually executes the binary would ignore it anyway.

== Other examples ==

The `src/` folder contains two other examples: `quad.cpp` and `intro.cpp`. The quad example will simply open a coder-colored window and output 8-bit music (from very short programs) for a couple of seconds.

The intro example is more interesting, since it contains a (extremely primitive) raycaster and can be compiled with CMake for a interactive program with a 'debug mode'. Just run:

{{{
cmake . && make clean all && ./src/stub -d -w
}}}

*NOTE:* you will need Boost, GLEW, etc. Chances are you already have them though.

This should open a window allowing mouse pan and WASD movement. You can still compile it with:

{{{
python dnload.py -v src/intro.cpp -o stub -lGL -lSDL
}}}

Have fun!

== Short summary of operation ==

When invoked, the script will:
  * Probe for suitable compiler, usually `gcc` or `clang`, `cl.exe` on Windows.
  * Search for header file it was supposed to generate. By default this is called `dnload.h`.
  * Examine the location the header file was found in. If a source file was given on command line, only operate on it. Otherwise take all source files from this location.
  * Preprocess the source files with the compiler found earlier.
  * Examine preprocessor output and locate all function calls made with a specific prefix. By default this prefix is `dnload_`.
  * Generate a loader code block that locates pointers to given functions.
  * Write the header file.

If the script was invoked to additionally generate the binary:
  * Search for usual binary utilities in addition to the compiler.
  * Compile given source file with flags aiming for small code footprint.
  * Perform a series on operations on the compiler output known to further reduce code footprint.
  * Link an output binary.
  * Possibly strip the generated binary.
  * Compress the produced binary and concatenate it with a shell scrip that will decompress and execute it.

----

= The quest for minimal ELF32 binaries =

This section of the documentation explores both the current and historical methods of reducing executable file size on `*`nix systems. If you are only interested in the current "best practice" operation of the script, you can [#Crafting_headers_manually skip directly therein].

== Compiler flags ==

We can alter the compiler output to produce smaller binaries both by making it actually optimize for size and by altering the output to be better compressable. The options would go into three categories:
  * Options that decrease size of generated code or constants.
  * Options that just happen to produce a smaller or better compressable binary.
  * Options that disable language features, making output smaller.

Despite Clang being all the rage nowadays, gcc seems to still produce binaries that size-optimize better. In particular, the script will attempt to use g++49 (latest available in FreeBSD at the time of writing) whenever possible, but any compiler may be specified with the `-C` or `--compiler` command line option.

Using g++, the flags of the first type (just smaller) would be:
  * `-Os`
  * `-ffast-math`
  * `-fomit-frame-pointer`
  * `-fsingle-precision-constant`
  * `-fwhole-program`

These are all self-explanatory. In general the mere `-Os -ffast-math -fomit-frame-pointer` seems to do an excellent job.

Also the following options, seem to produce consistently better compressable code:
  * `-march=pentium4`: After permutating through all available instruction sets with several different intros, Pentium 4 seems to usually yield the best results.
  * `-mpreferred-stack-boundary=2`: Forces the compiler to attempt keeping the stack aligned at `2`^`2 = 4` bytes. This seems to consistently perform better than the default of `16` bytes.

After these, the compiler needs to be prevented from thinking we would need any fancy language features:
  * `-fno-threadsafe-statics`: By default some code is generated to ensure thread-safe initialization of local static variables. This code seems to get generated even if no statics actually exist.
  * `-fno-asynchronous-unwind-tables`: Disables generation of stack unwind information that could be used to debug stack contents at locations other than exactly function call boundary.
  * `-fno-exceptions`: Self-evident.
  * `-fno-rtti`: Self-evident.

*NOTE:* One could ask why C++ to begin with if we're not using any of its features? The answer is, why not? After manually disabling all the features that would increase code footprint, we can always write C using a C++ compiler. In some cases C++ will be beneficial, but should never be detrimental.

== The shell unpack header ==

Scouring old releases, the first instance of a `*`nix 4k using a self-dumping shell script seems to be _helsinki-spiegelberg by tsygä_ [#References [12]]. However, instead of dumping an executable binary, this entry actually distributes the source and compiles it on the fly.

There are some other variants afterwards, but the first use of the modern one-line filedump can be found in _Yellow Rose of Texas by Fit & Bandwagon_ [#References [13]]. Consequently, also the first 'big' Linux 4k intro.

The concept of self-dumping shell script is to have the first `n` bytes of a file be plain text that will be executed by normal `sh`-compatible shells. The shell code will:
  * Extract the rest of the file using common `*`nix tools (the compressed data starts immediately after the script).
  * Write the extracted data as a file into system temporary folder.
  * Make the file executable.
  * Run it.
  * Remove the file after program exits since that's the proper thing to do.

The header in _Yellow Rose_ looks like this:

{{{
dd bs=1 skip=83<$0|gunzip>/tmp/T;cd /tmp;chmod +x T;__GL_FSAA_MODE=4 ./T;rm T;exit
}}}

There are multiple programs that crunch gzip files to as small spaces as possible, but modern `*`nix systems come with better compressors and better tricks. We use LZMA compression:

{{{
i=/tmp/i;tail -n+2 $0|lzcat>$i;chmod +x $i;$i;rm $i;exit
}}}

This unpack header has gone to 58 bytes (newline for `tail` is needed at the end) from the 66 needed by Marq. It also uses significantly better compression.

One could assume that `xz` format would be more advantageous than the earlier `lzma`, but this seems not to be the case as `lzma` headers are smaller. The modern `xz` toolkit allows free customization of the compression parameters. We do the compression using the following settings:

{{{
xz --format=lzma --lzma1=preset=9e,lc=1,lp=0,pb=0"
}}}

This seems to consistently yield the best results for binaries aiming at 4k.

For academic interest, the script can create output binaries using nothing besides the unpack header trick. To do this, use the command line flag *-m vanilla* (as in `--method`). This yields us the baseline whencefrom to begin our quest:

{{{
'src/hello_world.stripped': 1940 bytes
'src/hello_world': 637 bytes
'src/quad.stripped': 3496 bytes
'src/quad': 1507 bytes
}}}

The `stripped` binaries listed above are generated by just stripping all non-needed sections from output binaries. These include `.comment`, `.eh_frame`, `.eh_frame_hdr`, `.fini`, `.gnu.hash`, `.gnu.version`, `.jcr`, `.note`, `.note.ABI-tag` and `.note.tag`. Using the compiler/linker `-s` flag seems to leave some of these in, so `strip` is called manually afterwards.

== My symbol table is too big - dlopen/dlsym ==

Besides the modern unpack header, _Yellow Rose_ also introduced the concept of using POSIX `dlopen` [#References [14]] and `dlsym` [#References [15]] to load the OpenGL functions it required.

Why this is relevant is basically because the symbol tables, consume quite a lot of space. Taking a look into the FreeBSD system headers [#References [17]] we can examine the symbol structs (going into `.dynsym`):

{{{
typedef struct {
  Elf32_Word st_name; /* String table index of name. */
  Elf32_Addr st_value; /* Symbol value. */
  Elf32_Word st_size; /* Size of associated object. */
  unsigned char st_info; /* Type and binding information. */
  unsigned char st_other; /* Reserved (not used). */
  Elf32_Half st_shndx; /* Section index of symbol. */
} Elf32_Sym;
}}}

This is 16 bytes per symbol. In addition the linker will generate linkage tables (going into `.plt`), which seem to be at the very least 2 instructions, per symbol (look at _Prodedure Linkage Table_ in the ELF specification part 2 [#References [16]]). Global offset table adds 4 bytes each. In any case, we're talking roughly 30 bytes per symbol. Not counting the space consumed by the function names themselves.

Luckily, using the forementioned two symbols, we can perform dynamic loading ourselves. _Yellow Rose_ only loaded the GL functions this way, but using a clever arrangement of text, we can embed the library information in a text block at practically no cost:
  * First string is a library name, terminated by zero.
  * Successive strings are function names.
  * Two successive zeroes revert to initial state, next string will again be a library name.
  * Third successive zero stops loading.

This produces the following loader (using quad example):

{{{
static const char g_dynstr[] = ""
"libGL.so\0"
"glAttachShader\0"
"glCompileShader\0"
"glCreateProgram\0"
"glCreateShader\0"
"glDisable\0"
"glEnableVertexAttribArray\0"
"glGetAttribLocation\0"
"glGetUniformLocation\0"
"glLinkProgram\0"
"glRectf\0"
"glShaderSource\0"
"glUniform1f\0"
"glUseProgram\0"
"\0libSDL.so\0"
"SDL_GL_SwapBuffers\0"
"SDL_Init\0"
"SDL_OpenAudio\0"
"SDL_PauseAudio\0"
"SDL_PollEvent\0"
"SDL_Quit\0"
"SDL_SetVideoMode\0"
"SDL_ShowCursor\0"
"\0";
static void dnload(void)
{
  char *src = (char*)g_dynstr;
  void **dst = (void**)&g_symbol_table;
  do {
    void *handle = dlopen(src, RTLD_LAZY);
    for(;;)
    {
      while(*(src++));
      if(!*(src))
      {
        break;
      }
      *dst++ = dlsym(handle, src);
    }
  } while(*(++src));
}
}}}

Recompiling with *-m dlfcn* we get new sizes. Interestingly, even though the size of hello world example is reduced, its compressed size is increased due to increasing complexity. On any nontrivial program the tradeoff is still worth it.

{{{
'hello_world.stripped': 1568 bytes
'hello_world': 752 bytes
'quad.stripped': 2748 bytes
'quad': 1408 bytes
}}}

*NOTE:* On FreeBSD, user must now additionally link against `libthr`. Since SDL is not explicitly linked against, it is not pulling the thread library as consequence. It seems threading is not properly initialized unless the dynamic linker gets to load `libthr`.

*NOTE:* On Linux, the functions are contained in `libdl`, not `libc`.

== Import by hash - scouring ELF32 headers ==

TODO: fill

== Crafting headers manually ==

TODO: fill

----

= Acknowledgements =

This script would not have been possible without the prior work done by various other parties. Especially the following parties deserve kudos for their efforts:
  * *Marq/Fit* [#reference_1 [1]] for the original unpack header and dlopen/dlsym implementation.
  * *Brian Raiter* for _A Whirlwind Tutorial on Creating Really Teensy ELF Executables for Linux_ [#References [2]] and the insight of interleaving headers.
  * *parcelshit* [#References [3]] and *las/Mercury* [#References [4]] for the original ELF32 import-by hash algorithm.
  * *Hymy* [#References [5]] and *Ye Olde Laptops Posse* [#References [6]] for earlier forays into manual ELF32 header construction.
  * *viznut/PWP* [#References [7]] for the series _Experimental music from very short C programs_ [#References [8]], a snipped of which is used in one of the examples.

The list might be missing some parties, that are thus not getting the credit they deserve. If you notice this, please help correct the error(s).

----

= Legalese =

All contained code is licenced under the [https://code.google.com/p/faemiyah-demoscene/source/browse/trunk/dnload/COPYING new BSD licence] [#References [9]].

Note that this licence only pertains to the code of the script(s) themselves. There are no restrictions imposed on the end products of the script(s) just like there are no restrictions imposed on a binary built with a compiler.

And to be honest, even that doesn't really mean anything. Just do whatever you want, but if you improve on the mechanisms, I'd probably prefer to incorporate the improvements.

----

= FAQ =

==== No-one runs 32-bit FreeBSD anymore, especially if it's only for curiosities like this. Why bother? ====

Even on a 64-bit system, you should be able to execute the result file if the compatibility layer is set up correctly. The easiest way to do it is to just install a 32-bit jail [#References [10]] and point `LD_32_LIBRARY_PATH` environment variable to the `/usr/local/lib` of that jail. This has the added benefit of enabling full 32-bit compatibility and easy cross-compiling.

There are probably easy ways to do the same on Linux, but they are out of the scope of this document.

----

= TODO =
  * Should probably create the header file in a smart(er) manner if it's not found.
  * Add cross-compilation support, at the very least between `*`nix systems and the "maximum" operation mode.
  * Only SDL/OpenGL supported right now. Should probably also support GLFW.

----

= References =

<a name="reference_1">`[`1`]` [http://www.pouet.net/user.php?who=4078 Marq/Fit in Pouet]<br>
`[`2`]` [http://www.muppetlabs.com/~breadbox/software/tiny/teensy.html A Whirlwind Tutorial on Creating Really Teensy ELF Executables for Linux]<br>
`[`3`]` [http://www.pouet.net/user.php?who=9348 parcelshit in Pouet]<br>
`[`4`]` [http://www.pouet.net/user.php?who=4548 las/Mercury in Pouet]<br>
`[`5`]` [http://www.pouet.net/groups.php?which=11106 Hymy in Pouet]<br>
`[`6`]` [http://www.pouet.net/groups.php?which=11436 Ye Olde Laptops Posse in Pouet]<br>
`[`7`]` [http://www.pouet.net/user.php?who=2547 viznut/PWP in Pouet]<br>
`[`8`]` [https://www.youtube.com/watch?v=tCRPUv8V22o Music from very short programs - the 3rd iteration in Youtube]<br>
`[`9`]` [http://opensource.org/licenses/BSD-3-Clause New BSD licence]<br>
`[`10`]` [http://www.freebsd.org/doc/handbook/jails.html Chapter 15. Jails in FreeBSD manual]<br>
`[`11`]` [http://www.freebsd.org/doc/en/books/developers-handbook/x86-system-calls.html Chapter 11.3. System Calls in FreeBSD manual]<br>
`[`12`]` [http://www.pouet.net/prod.php?which=5021 helsinki-spiegelberg by tsygä in Pouet]<br>
`[`13`]` [http://www.pouet.net/prod.php?which=10562 Yellow Rose of Texas by Fit & Bandwagon in Pouet]<br>
`[`14`]` [http://pubs.opengroup.org/onlinepubs/009695399/functions/dlopen.html dlopen specification at The Open Group Base Specifications]<br>
`[`15`]` [http://pubs.opengroup.org/onlinepubs/009695399/functions/dlsym.html dlopen specification at The Open Group Base Specifications]<br>
`[`16`]` [http://www.skyfree.org/linux/references/ELF_Format.pdf ELF Format Specification]<br>
`[`17`]` [http://svnweb.freebsd.org/base/stable/10/sys/sys/ FreeBSD system headers]